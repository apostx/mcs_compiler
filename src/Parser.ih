// Generated by Bisonc++ V4.09.02

// Include this file in the sources of the class Parser.

// $insert class.h
#include "Parser.h"

inline void Parser::error(char const *msg) {
	std::cerr << d_loc__.first_line << ": Syntax error" << std::endl;
	exit(1);
}

inline void Parser::checkVariableExists(std::string const *variableName) {
	if (symboltable.count(*variableName) == 0) {
		std::cerr << d_loc__.first_line << ": Semantics error: Missing declaration: \"" << *variableName << "\"" << std::endl;
		exit(1);
	}
}

inline void Parser::manageDeclaration(std::string const *variableName) {
	if (0 < symboltable.count(*variableName)) {
		std::cerr << d_loc__.first_line << ": Semantics error: Duplicate declaration: \"" << *variableName << "\" (line:" << symboltable[*variableName] << ")" << std::endl;
		exit(1);
	} else
		symboltable[*variableName] = d_loc__.first_line;
}

// $insert lex
inline int Parser::lex() {
	int ret = lexer.yylex();

	if(ret == Parser::IDENTIFIER)
		d_val__.text = new std::string(lexer.YYText());

	d_loc__.first_line = lexer.lineno();
	return ret;
}

inline void Parser::print() {
	print__(); // displays tokens if --print was specified
}

inline void Parser::exceptionHandler__(std::exception const &exc) {
	throw; // re-implement to handle exceptions thrown by actions
}

// Add here includes that are only required for the compilation 
// of Parser's sources.

// UN-comment the next using-declaration if you want to use
// int Parser's sources symbols from the namespace std without
// specifying std::

//using namespace std;
